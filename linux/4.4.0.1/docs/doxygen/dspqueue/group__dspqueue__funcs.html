<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>dspqueue: Asynchronous DSP Packet Queue API Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">dspqueue
   </div>
   <div id="projectbrief">Asynchronous DSP Packet Queue</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__dspqueue__funcs.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Asynchronous DSP Packet Queue API Functions</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga950b8def5e0cf1bb1be995f04ac93b98"><td class="memItemLeft" align="right" valign="top">AEEResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspqueue__funcs.html#ga950b8def5e0cf1bb1be995f04ac93b98">dspqueue_create</a> (int domain, uint32_t flags, uint32_t req_queue_size, uint32_t resp_queue_size, <a class="el" href="group__dspqueue__types.html#ga995d892031371d72dadacad557c3b3f5">dspqueue_callback_t</a> packet_callback, <a class="el" href="group__dspqueue__types.html#ga995d892031371d72dadacad557c3b3f5">dspqueue_callback_t</a> error_callback, void *callback_context, <a class="el" href="group__dspqueue__types.html#ga5448e02f282d07190216b64410db2299">dspqueue_t</a> *queue)</td></tr>
<tr class="separator:ga950b8def5e0cf1bb1be995f04ac93b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3064ebee86693894b90551790f67f0f"><td class="memItemLeft" align="right" valign="top">AEEResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspqueue__funcs.html#gaf3064ebee86693894b90551790f67f0f">dspqueue_close</a> (<a class="el" href="group__dspqueue__types.html#ga5448e02f282d07190216b64410db2299">dspqueue_t</a> queue)</td></tr>
<tr class="separator:gaf3064ebee86693894b90551790f67f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5acdc8791bbb1c76b5ced072655a9577"><td class="memItemLeft" align="right" valign="top">AEEResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspqueue__funcs.html#ga5acdc8791bbb1c76b5ced072655a9577">dspqueue_export</a> (<a class="el" href="group__dspqueue__types.html#ga5448e02f282d07190216b64410db2299">dspqueue_t</a> queue, uint64_t *queue_id)</td></tr>
<tr class="separator:ga5acdc8791bbb1c76b5ced072655a9577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga794967ded39fa2e5c2cc1954a3ebaabd"><td class="memItemLeft" align="right" valign="top">AEEResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspqueue__funcs.html#ga794967ded39fa2e5c2cc1954a3ebaabd">dspqueue_import</a> (uint64_t queue_id, <a class="el" href="group__dspqueue__types.html#ga995d892031371d72dadacad557c3b3f5">dspqueue_callback_t</a> packet_callback, <a class="el" href="group__dspqueue__types.html#ga995d892031371d72dadacad557c3b3f5">dspqueue_callback_t</a> error_callback, void *callback_context, <a class="el" href="group__dspqueue__types.html#ga5448e02f282d07190216b64410db2299">dspqueue_t</a> *queue)</td></tr>
<tr class="separator:ga794967ded39fa2e5c2cc1954a3ebaabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab45bdf9fd39b1631a0019e27016458a6"><td class="memItemLeft" align="right" valign="top">AEEResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspqueue__funcs.html#gab45bdf9fd39b1631a0019e27016458a6">dspqueue_write_noblock</a> (<a class="el" href="group__dspqueue__types.html#ga5448e02f282d07190216b64410db2299">dspqueue_t</a> queue, uint32_t flags, uint32_t num_buffers, struct <a class="el" href="structdspqueue__buffer.html">dspqueue_buffer</a> *buffers, uint32_t message_length, const uint8_t *message)</td></tr>
<tr class="separator:gab45bdf9fd39b1631a0019e27016458a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca2e96067f395726d50d6aea5606944c"><td class="memItemLeft" align="right" valign="top">AEEResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspqueue__funcs.html#gaca2e96067f395726d50d6aea5606944c">dspqueue_write</a> (<a class="el" href="group__dspqueue__types.html#ga5448e02f282d07190216b64410db2299">dspqueue_t</a> queue, uint32_t flags, uint32_t num_buffers, struct <a class="el" href="structdspqueue__buffer.html">dspqueue_buffer</a> *buffers, uint32_t message_length, const uint8_t *message, uint32_t timeout_us)</td></tr>
<tr class="separator:gaca2e96067f395726d50d6aea5606944c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1a9b7828d3e0b52a30a572755b7d9f3"><td class="memItemLeft" align="right" valign="top">AEEResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspqueue__funcs.html#gae1a9b7828d3e0b52a30a572755b7d9f3">dspqueue_read_noblock</a> (<a class="el" href="group__dspqueue__types.html#ga5448e02f282d07190216b64410db2299">dspqueue_t</a> queue, uint32_t *flags, uint32_t max_buffers, uint32_t *num_buffers, struct <a class="el" href="structdspqueue__buffer.html">dspqueue_buffer</a> *buffers, uint32_t max_message_length, uint32_t *message_length, uint8_t *message)</td></tr>
<tr class="separator:gae1a9b7828d3e0b52a30a572755b7d9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93ec3144ce7ce9f88ba6bf5a77a7d0f2"><td class="memItemLeft" align="right" valign="top">AEEResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspqueue__funcs.html#ga93ec3144ce7ce9f88ba6bf5a77a7d0f2">dspqueue_read</a> (<a class="el" href="group__dspqueue__types.html#ga5448e02f282d07190216b64410db2299">dspqueue_t</a> queue, uint32_t *flags, uint32_t max_buffers, uint32_t *num_buffers, struct <a class="el" href="structdspqueue__buffer.html">dspqueue_buffer</a> *buffers, uint32_t max_message_length, uint32_t *message_length, uint8_t *message, uint32_t timeout_us)</td></tr>
<tr class="separator:ga93ec3144ce7ce9f88ba6bf5a77a7d0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06b438d6305f50635ec8671a14ce018c"><td class="memItemLeft" align="right" valign="top">AEEResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspqueue__funcs.html#ga06b438d6305f50635ec8671a14ce018c">dspqueue_peek_noblock</a> (<a class="el" href="group__dspqueue__types.html#ga5448e02f282d07190216b64410db2299">dspqueue_t</a> queue, uint32_t *flags, uint32_t *num_buffers, uint32_t *message_length)</td></tr>
<tr class="separator:ga06b438d6305f50635ec8671a14ce018c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e15dbebace44b8ab983bd5b11753d37"><td class="memItemLeft" align="right" valign="top">AEEResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspqueue__funcs.html#ga2e15dbebace44b8ab983bd5b11753d37">dspqueue_peek</a> (<a class="el" href="group__dspqueue__types.html#ga5448e02f282d07190216b64410db2299">dspqueue_t</a> queue, uint32_t *flags, uint32_t *num_buffers, uint32_t *message_length, uint32_t timeout_us)</td></tr>
<tr class="separator:ga2e15dbebace44b8ab983bd5b11753d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85b8c8c2b540cebcf854274aec8b346d"><td class="memItemLeft" align="right" valign="top">AEEResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspqueue__funcs.html#ga85b8c8c2b540cebcf854274aec8b346d">dspqueue_write_early_wakeup_noblock</a> (<a class="el" href="group__dspqueue__types.html#ga5448e02f282d07190216b64410db2299">dspqueue_t</a> queue, uint32_t wakeup_delay, uint32_t packet_flags)</td></tr>
<tr class="separator:ga85b8c8c2b540cebcf854274aec8b346d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc22ba656e69fc8809ef26e43290de3c"><td class="memItemLeft" align="right" valign="top">AEEResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dspqueue__funcs.html#gadc22ba656e69fc8809ef26e43290de3c">dspqueue_get_stat</a> (<a class="el" href="group__dspqueue__types.html#ga5448e02f282d07190216b64410db2299">dspqueue_t</a> queue, enum <a class="el" href="group__dspqueue__consts.html#ga510873ac5a0ef07bba20a7e054bdb3d6">dspqueue_stat</a> stat, uint64_t *value)</td></tr>
<tr class="separator:gadc22ba656e69fc8809ef26e43290de3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaf3064ebee86693894b90551790f67f0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AEEResult dspqueue_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dspqueue__types.html#ga5448e02f282d07190216b64410db2299">dspqueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close a queue and free all memory associated with it. The function can be called on the host CPU with queue handles from <a class="el" href="group__dspqueue__funcs.html#ga950b8def5e0cf1bb1be995f04ac93b98">dspqueue_create()</a> or on the DSP with handles from <a class="el" href="group__dspqueue__funcs.html#ga794967ded39fa2e5c2cc1954a3ebaabd">dspqueue_import()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>Queue handle from dsp_queue_create() from dsp_queue_import().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code on failure.<ul>
<li>AEE_EBADPARM: Bad parameters, e.g. The queue is open on the DSP when attempting to close it on the host CPU</li>
<li>AEE_EBADSTATE: Bad internal state </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga950b8def5e0cf1bb1be995f04ac93b98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AEEResult dspqueue_create </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>req_queue_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>resp_queue_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dspqueue__types.html#ga995d892031371d72dadacad557c3b3f5">dspqueue_callback_t</a>&#160;</td>
          <td class="paramname"><em>packet_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dspqueue__types.html#ga995d892031371d72dadacad557c3b3f5">dspqueue_callback_t</a>&#160;</td>
          <td class="paramname"><em>error_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dspqueue__types.html#ga5448e02f282d07190216b64410db2299">dspqueue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new queue to communicate with the DSP. Queues can only be created on the host CPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>DSP to communicate with (CDSP_DOMAIN_ID in remote.h for cDSP) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Queue creation flags </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">req_queue_size</td><td>Total request queue memory size in bytes; use 0 for system default </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resp_queue_size</td><td>Total response queue memory size in bytes; use 0 for system default </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packet_callback</td><td>Callback function called when there are new packets to read. The call will be done in a different thread's context. NULL to disable the callback. Clients cannot use blocking read calls if a packet callback has been set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error_callback</td><td>Callback function called on unrecoverable errors. NULL to disable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback_context</td><td>Context pointer for callback functions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">queue</td><td>Queue handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code on failure.<ul>
<li>AEE_ENOMEMORY: Not enough memory available</li>
<li>AEE_EUNSUPPORTED: Message queue not supported on the given DSP</li>
<li>AEE_EBADPARM: Bad parameters, e.g. Invalid domain (use CDSP_DOMAIN_ID for cDSP), Too many queues open for the DSP in this process</li>
<li>AEE_ERPC: Internal RPC error, e.g. Queue list corrupt</li>
<li>AEE_EBADSTATE: Bad internal state </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga5acdc8791bbb1c76b5ced072655a9577"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AEEResult dspqueue_export </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dspqueue__types.html#ga5448e02f282d07190216b64410db2299">dspqueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>queue_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Export a queue to the DSP. The CPU-side client calls this function, passes the ID to the DSP, which can then call <a class="el" href="group__dspqueue__funcs.html#ga794967ded39fa2e5c2cc1954a3ebaabd">dspqueue_import()</a> to access the queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>Queue handle from <a class="el" href="group__dspqueue__funcs.html#ga950b8def5e0cf1bb1be995f04ac93b98">dspqueue_create()</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">queue_id</td><td>Queue ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gadc22ba656e69fc8809ef26e43290de3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AEEResult dspqueue_get_stat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dspqueue__types.html#ga5448e02f282d07190216b64410db2299">dspqueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__dspqueue__consts.html#ga510873ac5a0ef07bba20a7e054bdb3d6">dspqueue_stat</a>&#160;</td>
          <td class="paramname"><em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve statistics from a queue. Statistics are relative to the queue as viewed from the current endpoint (e.g. "read queue" refers to the queue as being read by the current endpoint).</p>
<p>Reading an accumulating statistic (such as early wakeup wait time) will reset it to zero.</p>
<p>Note that statistics values are only valid at the time when they're read. By the time this function returns the values may have changed due to actions from another thread or the other queue endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>Queue handle from <a class="el" href="group__dspqueue__funcs.html#ga950b8def5e0cf1bb1be995f04ac93b98">dspqueue_create()</a> or <a class="el" href="group__dspqueue__funcs.html#ga794967ded39fa2e5c2cc1954a3ebaabd">dspqueue_import()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stat</td><td>Statistic to read, see enum dspqueue_stat </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Statistic value. Reading a statistic will reset it to zero</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code on failure.<ul>
<li>AEE_EBADPARM: Invalid statistic </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga794967ded39fa2e5c2cc1954a3ebaabd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AEEResult dspqueue_import </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dspqueue__types.html#ga995d892031371d72dadacad557c3b3f5">dspqueue_callback_t</a>&#160;</td>
          <td class="paramname"><em>packet_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dspqueue__types.html#ga995d892031371d72dadacad557c3b3f5">dspqueue_callback_t</a>&#160;</td>
          <td class="paramname"><em>error_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dspqueue__types.html#ga5448e02f282d07190216b64410db2299">dspqueue_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Import a queue on the DSP based on an ID passed in from the host CPU. The DSP client can use the returned queue handle to access the queue and communicate with its host CPU counterpart.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue_id</td><td>Queue ID from <a class="el" href="group__dspqueue__funcs.html#ga5acdc8791bbb1c76b5ced072655a9577">dspqueue_export()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packet_callback</td><td>Callback function called when there are new packets to read. The call will be done in a different thread's context. NULL to disable the callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error_callback</td><td>Callback function called on unrecoverable errors. NULL to disable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback_context</td><td>Context pointer fo callback functions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">queue</td><td>Queue handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code on failure.<ul>
<li>AEE_EITEMBUSY: The queue has already been imported</li>
<li>AEE_EQURTTHREADCREATE: Unable to create callback thread; the system may have reached its thread limit.</li>
<li>AEE_EBADSTATE: Bad internal state </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga2e15dbebace44b8ab983bd5b11753d37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AEEResult dspqueue_peek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dspqueue__types.html#ga5448e02f282d07190216b64410db2299">dspqueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>num_buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>message_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout_us</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve information for the next packet, without reading it from the queue and advancing the read pointer. If the queue is empty this function will block until a packet is available or the request times out.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>Queue handle from <a class="el" href="group__dspqueue__funcs.html#ga950b8def5e0cf1bb1be995f04ac93b98">dspqueue_create()</a> or <a class="el" href="group__dspqueue__funcs.html#ga794967ded39fa2e5c2cc1954a3ebaabd">dspqueue_import()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flags</td><td>Packet flags. See enum <a class="el" href="group__dspqueue__consts.html#ga6a80743e969499be8323ecbf1a7d96c4">dspqueue_packet_flags</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">num_buffers</td><td>Number of buffer references in packet </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">message_length</td><td>Packet message length in bytes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">timeout_us</td><td>Timeout in microseconds; use DSPQUEUE_TIMEOUT_NONE to block indefinitely until a packet is available or zero for non-blocking behavior.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code on failure.<ul>
<li>AEE_EEXPIRED: Request timed out</li>
<li>AEE_EINTERRUPTED: The request was canceled</li>
<li>AEE_EBADITEM: The queue contains a corrupted packet. Internal error.</li>
<li>AEE_EBADSTATE: Bad internal state </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga06b438d6305f50635ec8671a14ce018c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AEEResult dspqueue_peek_noblock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dspqueue__types.html#ga5448e02f282d07190216b64410db2299">dspqueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>num_buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>message_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve information for the next packet if available, without reading it from the queue and advancing the read pointer. This function will not block, but will instead return an error if the queue is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>Queue handle from <a class="el" href="group__dspqueue__funcs.html#ga950b8def5e0cf1bb1be995f04ac93b98">dspqueue_create()</a> or <a class="el" href="group__dspqueue__funcs.html#ga794967ded39fa2e5c2cc1954a3ebaabd">dspqueue_import()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flags</td><td>Packet flags. See enum <a class="el" href="group__dspqueue__consts.html#ga6a80743e969499be8323ecbf1a7d96c4">dspqueue_packet_flags</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">num_buffers</td><td>Number of buffer references in packet </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">message_length</td><td>Packet message length in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code on failure.<ul>
<li>AEE_EWOULDBLOCK: The queue is empty; try again later</li>
<li>AEE_EBADITEM: The queue contains a corrupted packet. Internal error.</li>
<li>AEE_EBADSTATE: Bad internal state </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga93ec3144ce7ce9f88ba6bf5a77a7d0f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AEEResult dspqueue_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dspqueue__types.html#ga5448e02f282d07190216b64410db2299">dspqueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>num_buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structdspqueue__buffer.html">dspqueue_buffer</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_message_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>message_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout_us</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a packet from a queue. If the queue is empty this function will block until a packet is available or the request times out. The queue must not have a packet callback set.</p>
<p>This function will read packet contents directly into client-provided buffers. The buffers must be large enough to fit contents from the packet or the call will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>Queue handle from <a class="el" href="group__dspqueue__funcs.html#ga950b8def5e0cf1bb1be995f04ac93b98">dspqueue_create()</a> or <a class="el" href="group__dspqueue__funcs.html#ga794967ded39fa2e5c2cc1954a3ebaabd">dspqueue_import()</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flags</td><td>Packet flags. See enum <a class="el" href="group__dspqueue__consts.html#ga6a80743e969499be8323ecbf1a7d96c4">dspqueue_packet_flags</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_buffers</td><td>The maximum number of buffer references that can fit in the "buffers" parameter </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">num_buffers</td><td>The number of buffer references in the packet </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffers</td><td>Buffer reference data from the packet </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_message_length</td><td>Maximum message length that can fit in the "message" parameter </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">message_length</td><td>Message length in bytes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">message</td><td>Packet message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_us</td><td>Timeout in microseconds; use DSPQUEUE_TIMEOUT_NONE to block indefinitely until a packet is available or zero for non-blocking behavior.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code on failure.<ul>
<li>AEE_EBADPARM: Bad parameters, e.g. The packet is too large to fit in the provided buffers</li>
<li>AEE_ENOSUCHMAP: The packet refers to an unmapped buffer. Buffers must be mapped to the DSP with fastrpc_mmap() before they can be used in queue packets.</li>
<li>AEE_EBADITEM: The queue contains a corrupted packet. Internal error.</li>
<li>AEE_EBADSTATE: Bad internal state</li>
<li>AEE_EEXPIRED: Request timed out</li>
<li>AEE_EINTERRUPTED: The request was canceled </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gae1a9b7828d3e0b52a30a572755b7d9f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AEEResult dspqueue_read_noblock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dspqueue__types.html#ga5448e02f282d07190216b64410db2299">dspqueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>num_buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structdspqueue__buffer.html">dspqueue_buffer</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_message_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>message_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a packet from a queue. This variant of the function will not block, and will instead return AEE_EWOULDBLOCK if the queue does not have enough space for the packet.</p>
<p>This function will read packet contents directly into client-provided buffers. The buffers must be large enough to fit contents from the packet or the call will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>Queue handle from <a class="el" href="group__dspqueue__funcs.html#ga950b8def5e0cf1bb1be995f04ac93b98">dspqueue_create()</a> or <a class="el" href="group__dspqueue__funcs.html#ga794967ded39fa2e5c2cc1954a3ebaabd">dspqueue_import()</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flags</td><td>Packet flags. See enum <a class="el" href="group__dspqueue__consts.html#ga6a80743e969499be8323ecbf1a7d96c4">dspqueue_packet_flags</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_buffers</td><td>The maximum number of buffer references that can fit in the "buffers" parameter </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">num_buffers</td><td>The number of buffer references in the packet </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffers</td><td>Buffer reference data from the packet </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_message_length</td><td>Maximum message length that can fit in the "message" parameter </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">message_length</td><td>Message length in bytes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">message</td><td>Packet message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code on failure.<ul>
<li>AEE_EBADPARM: Bad parameters, e.g. The packet is too large to fit in the provided buffers</li>
<li>AEE_ENOSUCHMAP: The packet refers to an unmapped buffer. Buffers must be mapped to the DSP with fastrpc_mmap() before they can be used in queue packets.</li>
<li>AEE_EWOULDBLOCK: The queue is empty; try again later</li>
<li>AEE_EBADITEM: The queue contains a corrupted packet. Internal error.</li>
<li>AEE_EBADSTATE: Bad internal state </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaca2e96067f395726d50d6aea5606944c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AEEResult dspqueue_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dspqueue__types.html#ga5448e02f282d07190216b64410db2299">dspqueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structdspqueue__buffer.html">dspqueue_buffer</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>message_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout_us</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a packet to a queue. If the queue is full this function will block until space becomes available or the request times out.</p>
<p>With this function the client can pass separate pointers to the buffer references and message to include in the packet and the library copies the contents directly to the queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>Queue handle from <a class="el" href="group__dspqueue__funcs.html#ga950b8def5e0cf1bb1be995f04ac93b98">dspqueue_create()</a> or <a class="el" href="group__dspqueue__funcs.html#ga794967ded39fa2e5c2cc1954a3ebaabd">dspqueue_import()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Packet flags. See enum <a class="el" href="group__dspqueue__consts.html#ga6a80743e969499be8323ecbf1a7d96c4">dspqueue_packet_flags</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_buffers</td><td>Number of buffer references to insert to the packet; zero if there are no buffer references </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffers</td><td>Pointer to buffer references </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message_length</td><td>Message length in bytes; zero if the packet contains no message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Pointer to packet message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_us</td><td>Timeout in microseconds; use DSPQUEUE_TIMEOUT_NONE to block indefinitely until a space is available or zero for non-blocking behavior.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code on failure.<ul>
<li>AEE_EBADPARM: Bad parameters, e.g. buffers is NULL when num_buffers &gt; 0 The packet is too long to fit in the queue. The call will never succeed.</li>
<li>AEE_ENOSUCHMAP: Attempt to refer to an unmapped buffer. Buffers must be mapped to the DSP with fastrpc_mmap() before they can be used in queue packets.</li>
<li>AEE_EEXPIRED: Request timed out</li>
<li>AEE_EINTERRUPTED: The request was canceled</li>
<li>AEE_EBADSTATE: Bad internal state </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga85b8c8c2b540cebcf854274aec8b346d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AEEResult dspqueue_write_early_wakeup_noblock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dspqueue__types.html#ga5448e02f282d07190216b64410db2299">dspqueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wakeup_delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>packet_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write an early wakeup packet to the queue. Early wakeup packets are used to bring the recipient out of a low-power state in anticipation of a real message packet being availble shortly, and are typically used from the DSP to signal that an operation is almost complete.</p>
<p>This function will return immediately if the queue is full. There is no blocking variant of this function; if the queue is full the other endpoint should already be processing data and an early wakeup would not be useful.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>Queue handle from <a class="el" href="group__dspqueue__funcs.html#ga950b8def5e0cf1bb1be995f04ac93b98">dspqueue_create()</a> or <a class="el" href="group__dspqueue__funcs.html#ga794967ded39fa2e5c2cc1954a3ebaabd">dspqueue_import()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wakeup_delay</td><td>Wakeup time in microseconds; this indicates how soon the real message packet should be available. Zero if not known. The recipient can use this information to determine how to wait for the packet. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packet_flags</td><td>Flags for the upcoming packet if known. The framework can use this information to optimize its behavior if the flags match the upcoming packet; if not known set to zero. See enum <a class="el" href="group__dspqueue__consts.html#ga6a80743e969499be8323ecbf1a7d96c4">dspqueue_packet_flags</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code on failure.<ul>
<li>AEE_EWOULDBLOCK: The queue is full</li>
<li>AEE_EBADSTATE: Bad internal state </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gab45bdf9fd39b1631a0019e27016458a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AEEResult dspqueue_write_noblock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dspqueue__types.html#ga5448e02f282d07190216b64410db2299">dspqueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structdspqueue__buffer.html">dspqueue_buffer</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>message_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a packet to a queue. This variant of the function will not block, and will instead return AEE_EWOULDBLOCK if the queue does not have enough space for the packet.</p>
<p>With this function the client can pass separate pointers to the buffer references and message to include in the packet and the library copies the contents directly to the queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>Queue handle from <a class="el" href="group__dspqueue__funcs.html#ga950b8def5e0cf1bb1be995f04ac93b98">dspqueue_create()</a> or <a class="el" href="group__dspqueue__funcs.html#ga794967ded39fa2e5c2cc1954a3ebaabd">dspqueue_import()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Packet flags. See enum <a class="el" href="group__dspqueue__consts.html#ga6a80743e969499be8323ecbf1a7d96c4">dspqueue_packet_flags</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_buffers</td><td>Number of buffer references to insert to the packet; zero if there are no buffer references </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffers</td><td>Pointer to buffer references </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message_length</td><td>Message length in bytes; zero if the packet contains no message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Pointer to packet message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code on failure.<ul>
<li>AEE_EWOULDBLOCK: The queue is full</li>
<li>AEE_EBADPARM: Bad parameters, e.g. buffers is NULL when num_buffers &gt; 0 , The packet is too long to fit in the queue. The call will never succeed.</li>
<li>AEE_ENOSUCHMAP: Attempt to refer to an unmapped buffer. Buffers must be mapped to the DSP with fastrpc_mmap() before they can be used in queue packets.</li>
<li>AEE_EBADSTATE: Bad internal state </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright  2020 Qualcomm Technologies Inc. All rights reserved.  Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
