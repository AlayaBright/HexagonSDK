<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>worker_pool: worker_pool.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">worker_pool
   </div>
   <div id="projectbrief">DSP thread pool</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('worker__pool_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">worker_pool.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Utility providing a thread worker pool for multi-threaded computer vision (or other compute) applications.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;AEEStdDef.h&gt;</code><br />
<code>#include &lt;AEEStdErr.h&gt;</code><br />
</div>
<p><a href="worker__pool_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structworker__pool__job__t.html">worker_pool_job_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">descriptor for requested callback  <a href="structworker__pool__job__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structworker__synctoken__t.html">worker_synctoken_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">opaque client view of synchronization token for job submitter and workers. Internals hidden in implementation.  <a href="structworker__synctoken__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ac20a7c648028419b346fb3254aab981e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac20a7c648028419b346fb3254aab981e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="worker__pool_8h.html#ac20a7c648028419b346fb3254aab981e">WORKERPOOL_API</a>&#160;&#160;&#160;__attribute__ ((visibility (&quot;default&quot;)))</td></tr>
<tr class="memdesc:ac20a7c648028419b346fb3254aab981e"><td class="mdescLeft">&#160;</td><td class="mdescRight">MACRO enables function to be visible in shared-library case. <br /></td></tr>
<tr class="separator:ac20a7c648028419b346fb3254aab981e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae349f8fec14a7cc3d663cf7eecf5a527"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae349f8fec14a7cc3d663cf7eecf5a527"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="worker__pool_8h.html#ae349f8fec14a7cc3d663cf7eecf5a527">MAX_NUM_WORKERS</a>&#160;&#160;&#160;6</td></tr>
<tr class="memdesc:ae349f8fec14a7cc3d663cf7eecf5a527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum supported number of worker threads. <br /></td></tr>
<tr class="separator:ae349f8fec14a7cc3d663cf7eecf5a527"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a566c9b229d5668cf80db4568d2793415"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a566c9b229d5668cf80db4568d2793415"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="worker__pool_8h.html#a566c9b229d5668cf80db4568d2793415">worker_callback_t</a>) (void *)</td></tr>
<tr class="memdesc:a566c9b229d5668cf80db4568d2793415"><td class="mdescLeft">&#160;</td><td class="mdescRight">signature of callbacks to be invoked by worker threads <br /></td></tr>
<tr class="separator:a566c9b229d5668cf80db4568d2793415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a4cc2847bd9e48dd376c0ff7a2331c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59a4cc2847bd9e48dd376c0ff7a2331c"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="worker__pool_8h.html#a59a4cc2847bd9e48dd376c0ff7a2331c">worker_pool_context_t</a></td></tr>
<tr class="memdesc:a59a4cc2847bd9e48dd376c0ff7a2331c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef of worker_pool context. <br /></td></tr>
<tr class="separator:a59a4cc2847bd9e48dd376c0ff7a2331c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a04273bd14d0e2d7edd94d7f17ff91434"><td class="memItemLeft" align="right" valign="top"><a class="el" href="worker__pool_8h.html#ac20a7c648028419b346fb3254aab981e">WORKERPOOL_API</a> AEEResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="worker__pool_8h.html#a04273bd14d0e2d7edd94d7f17ff91434">worker_pool_init</a> (<a class="el" href="worker__pool_8h.html#a59a4cc2847bd9e48dd376c0ff7a2331c">worker_pool_context_t</a> *context)</td></tr>
<tr class="memdesc:a04273bd14d0e2d7edd94d7f17ff91434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a worker pool. Should be called by each control thread that requires its own worker pool.  <a href="#a04273bd14d0e2d7edd94d7f17ff91434">More...</a><br /></td></tr>
<tr class="separator:a04273bd14d0e2d7edd94d7f17ff91434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8cdece7ee5e320cb59f9fce0c89559e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="worker__pool_8h.html#ac20a7c648028419b346fb3254aab981e">WORKERPOOL_API</a> AEEResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="worker__pool_8h.html#ad8cdece7ee5e320cb59f9fce0c89559e">worker_pool_init_with_stack_size</a> (<a class="el" href="worker__pool_8h.html#a59a4cc2847bd9e48dd376c0ff7a2331c">worker_pool_context_t</a> *context, int stack_size)</td></tr>
<tr class="memdesc:ad8cdece7ee5e320cb59f9fce0c89559e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a worker pool with custom stack size of worker threads.  <a href="#ad8cdece7ee5e320cb59f9fce0c89559e">More...</a><br /></td></tr>
<tr class="separator:ad8cdece7ee5e320cb59f9fce0c89559e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd02f4147867c5eeacf9ae0b1c2daa05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="worker__pool_8h.html#ac20a7c648028419b346fb3254aab981e">WORKERPOOL_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="worker__pool_8h.html#abd02f4147867c5eeacf9ae0b1c2daa05">worker_pool_deinit</a> (<a class="el" href="worker__pool_8h.html#a59a4cc2847bd9e48dd376c0ff7a2331c">worker_pool_context_t</a> *context)</td></tr>
<tr class="memdesc:abd02f4147867c5eeacf9ae0b1c2daa05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kill worker threads and release worker pool resources. Must be called when pool owner no longer requires the pool.  <a href="#abd02f4147867c5eeacf9ae0b1c2daa05">More...</a><br /></td></tr>
<tr class="separator:abd02f4147867c5eeacf9ae0b1c2daa05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa175584740750358b0b5e93b384a5387"><td class="memItemLeft" align="right" valign="top"><a class="el" href="worker__pool_8h.html#ac20a7c648028419b346fb3254aab981e">WORKERPOOL_API</a> AEEResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="worker__pool_8h.html#aa175584740750358b0b5e93b384a5387">worker_pool_available</a> (<a class="el" href="worker__pool_8h.html#a59a4cc2847bd9e48dd376c0ff7a2331c">worker_pool_context_t</a> context)</td></tr>
<tr class="memdesc:aa175584740750358b0b5e93b384a5387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to determine if there is an established worker pool available to the calling thread. This is an optional call - if no pool is available but attempted to be used, everything works seamlessly, in the client's context (instead of worker context).  <a href="#aa175584740750358b0b5e93b384a5387">More...</a><br /></td></tr>
<tr class="separator:aa175584740750358b0b5e93b384a5387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14d34a9bcb539b0497919718088f8fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="worker__pool_8h.html#ac20a7c648028419b346fb3254aab981e">WORKERPOOL_API</a> AEEResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="worker__pool_8h.html#ad14d34a9bcb539b0497919718088f8fa">worker_pool_submit</a> (<a class="el" href="worker__pool_8h.html#a59a4cc2847bd9e48dd376c0ff7a2331c">worker_pool_context_t</a> context, <a class="el" href="structworker__pool__job__t.html">worker_pool_job_t</a> job)</td></tr>
<tr class="memdesc:ad14d34a9bcb539b0497919718088f8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a job to the worker pool.  <a href="#ad14d34a9bcb539b0497919718088f8fa">More...</a><br /></td></tr>
<tr class="separator:ad14d34a9bcb539b0497919718088f8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80249e93b966c3078003bb287acd793"><td class="memItemLeft" align="right" valign="top"><a class="el" href="worker__pool_8h.html#ac20a7c648028419b346fb3254aab981e">WORKERPOOL_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="worker__pool_8h.html#ad80249e93b966c3078003bb287acd793">worker_pool_synctoken_init</a> (<a class="el" href="structworker__synctoken__t.html">worker_synctoken_t</a> *token, unsigned int njobs)</td></tr>
<tr class="memdesc:ad80249e93b966c3078003bb287acd793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a synchronization token for job submitter and workers to use. Each worker callback must be given access to the token to release it, and job submitter will wait for all jobs to release the token. Internals are hidden from client.  <a href="#ad80249e93b966c3078003bb287acd793">More...</a><br /></td></tr>
<tr class="separator:ad80249e93b966c3078003bb287acd793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c041e704dfeaf36f56fdf5755f59ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="worker__pool_8h.html#ac20a7c648028419b346fb3254aab981e">WORKERPOOL_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="worker__pool_8h.html#aa2c041e704dfeaf36f56fdf5755f59ea">worker_pool_synctoken_jobdone</a> (<a class="el" href="structworker__synctoken__t.html">worker_synctoken_t</a> *token)</td></tr>
<tr class="memdesc:aa2c041e704dfeaf36f56fdf5755f59ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Needs to be called by the worker in the callback before exiting. The token must be available to the callback via the data pointer given to the callback during job submission.  <a href="#aa2c041e704dfeaf36f56fdf5755f59ea">More...</a><br /></td></tr>
<tr class="separator:aa2c041e704dfeaf36f56fdf5755f59ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9cab6a5eb138c6073688a80b6404c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="worker__pool_8h.html#ac20a7c648028419b346fb3254aab981e">WORKERPOOL_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="worker__pool_8h.html#a0c9cab6a5eb138c6073688a80b6404c4">worker_pool_synctoken_wait</a> (<a class="el" href="structworker__synctoken__t.html">worker_synctoken_t</a> *token)</td></tr>
<tr class="memdesc:a0c9cab6a5eb138c6073688a80b6404c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Job submitter calls this function after submitting all jobs to await their completion.  <a href="#a0c9cab6a5eb138c6073688a80b6404c4">More...</a><br /></td></tr>
<tr class="separator:a0c9cab6a5eb138c6073688a80b6404c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf50d789d00d0dc7025438d8caf422e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="worker__pool_8h.html#ac20a7c648028419b346fb3254aab981e">WORKERPOOL_API</a> AEEResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="worker__pool_8h.html#a4bf50d789d00d0dc7025438d8caf422e">worker_pool_set_thread_priority</a> (<a class="el" href="worker__pool_8h.html#a59a4cc2847bd9e48dd376c0ff7a2331c">worker_pool_context_t</a> context, unsigned int prio)</td></tr>
<tr class="memdesc:a4bf50d789d00d0dc7025438d8caf422e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the thread priority of the worker threads. Specified priority will be applied to all threads in the default worker pool. The threads that service boosted and background job requests will also be adjusted to be relative to the new default thread priority.  <a href="#a4bf50d789d00d0dc7025438d8caf422e">More...</a><br /></td></tr>
<tr class="separator:a4bf50d789d00d0dc7025438d8caf422e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d15fe88898200a38904d1bb6aaa3b43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="worker__pool_8h.html#ac20a7c648028419b346fb3254aab981e">WORKERPOOL_API</a> AEEResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="worker__pool_8h.html#a7d15fe88898200a38904d1bb6aaa3b43">worker_pool_get_thread_priority</a> (<a class="el" href="worker__pool_8h.html#a59a4cc2847bd9e48dd376c0ff7a2331c">worker_pool_context_t</a> context, unsigned int *prio)</td></tr>
<tr class="memdesc:a7d15fe88898200a38904d1bb6aaa3b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the thread priority of the default worker threads. This will return the current priority for one of the workers, which are all created with the same priority. If a user callback has changed one or more worker threads independently, there is no guarantee on which worker's priority is returned by this function.  <a href="#a7d15fe88898200a38904d1bb6aaa3b43">More...</a><br /></td></tr>
<tr class="separator:a7d15fe88898200a38904d1bb6aaa3b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457bfd4b34ab3b50d44a6920455f31d9"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="worker__pool_8h.html#a457bfd4b34ab3b50d44a6920455f31d9">worker_pool_atomic_inc_return</a> (unsigned int *target)</td></tr>
<tr class="memdesc:a457bfd4b34ab3b50d44a6920455f31d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility inline to atomically increment a variable. Useful in synchronizing jobs among worker threads, in cases where all job-related info can be determined by the job number.  <a href="#a457bfd4b34ab3b50d44a6920455f31d9">More...</a><br /></td></tr>
<tr class="separator:a457bfd4b34ab3b50d44a6920455f31d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071139b352e29ee508ba0ddad00f9393"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="worker__pool_8h.html#a071139b352e29ee508ba0ddad00f9393">worker_pool_atomic_dec_return</a> (unsigned int *target)</td></tr>
<tr class="memdesc:a071139b352e29ee508ba0ddad00f9393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility inline to atomically decrement a variable.  <a href="#a071139b352e29ee508ba0ddad00f9393">More...</a><br /></td></tr>
<tr class="separator:a071139b352e29ee508ba0ddad00f9393"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a4eea497540a1f60556f9e8b31d820585"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4eea497540a1f60556f9e8b31d820585"></a>
<a class="el" href="worker__pool_8h.html#ac20a7c648028419b346fb3254aab981e">WORKERPOOL_API</a> unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="worker__pool_8h.html#a4eea497540a1f60556f9e8b31d820585">num_workers</a></td></tr>
<tr class="memdesc:a4eea497540a1f60556f9e8b31d820585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of workers. <br /></td></tr>
<tr class="separator:a4eea497540a1f60556f9e8b31d820585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f48dde3634e494a984680cb81ec4704"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f48dde3634e494a984680cb81ec4704"></a>
<a class="el" href="worker__pool_8h.html#ac20a7c648028419b346fb3254aab981e">WORKERPOOL_API</a> unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="worker__pool_8h.html#a0f48dde3634e494a984680cb81ec4704">num_hvx128_contexts</a></td></tr>
<tr class="memdesc:a0f48dde3634e494a984680cb81ec4704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of hvx 128 bytes units available. <br /></td></tr>
<tr class="separator:a0f48dde3634e494a984680cb81ec4704"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Utility providing a thread worker pool for multi-threaded computer vision (or other compute) applications. </p>
<p>=============================================================================</p>
<p><a class="el" href="worker__pool_8h.html" title="Utility providing a thread worker pool for multi-threaded computer vision (or other compute) applicat...">worker_pool.h</a></p>
<p>Copyright (c) 2019-2020 Qualcomm Technologies Incorporated. All Rights Reserved. Qualcomm Proprietary and Confidential.</p>
<p>Export of this technology or software is regulated by the U.S. Government. Diversion contrary to U.S. law prohibited.</p>
<p>All ideas, data and information contained in or disclosed by this document are confidential and proprietary information of Qualcomm Technologies Incorporated and all rights therein are expressly reserved. By accepting this material the recipient agrees that this material and the information contained therein are held in confidence and in trust and will not be used, copied, reproduced in whole or in part, nor its contents revealed in any manner to others without the express written permission of Qualcomm Technologies Incorporated. </p><hr/>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a071139b352e29ee508ba0ddad00f9393"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int worker_pool_atomic_dec_return </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility inline to atomically decrement a variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>pointer to the variable being incremented</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value after decrementing </dd></dl>

</div>
</div>
<a class="anchor" id="a457bfd4b34ab3b50d44a6920455f31d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int worker_pool_atomic_inc_return </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility inline to atomically increment a variable. Useful in synchronizing jobs among worker threads, in cases where all job-related info can be determined by the job number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>pointer to the variable being incremented</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value after incrementing </dd></dl>

</div>
</div>
<a class="anchor" id="aa175584740750358b0b5e93b384a5387"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="worker__pool_8h.html#ac20a7c648028419b346fb3254aab981e">WORKERPOOL_API</a> AEEResult worker_pool_available </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="worker__pool_8h.html#a59a4cc2847bd9e48dd376c0ff7a2331c">worker_pool_context_t</a>&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to determine if there is an established worker pool available to the calling thread. This is an optional call - if no pool is available but attempted to be used, everything works seamlessly, in the client's context (instead of worker context). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>worker_pool_context_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 - no worker pool available. any other value - worker pool available. </dd></dl>

</div>
</div>
<a class="anchor" id="abd02f4147867c5eeacf9ae0b1c2daa05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="worker__pool_8h.html#ac20a7c648028419b346fb3254aab981e">WORKERPOOL_API</a> void worker_pool_deinit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="worker__pool_8h.html#a59a4cc2847bd9e48dd376c0ff7a2331c">worker_pool_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kill worker threads and release worker pool resources. Must be called when pool owner no longer requires the pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*context</td><td>worker_pool_context_t. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d15fe88898200a38904d1bb6aaa3b43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="worker__pool_8h.html#ac20a7c648028419b346fb3254aab981e">WORKERPOOL_API</a> AEEResult worker_pool_get_thread_priority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="worker__pool_8h.html#a59a4cc2847bd9e48dd376c0ff7a2331c">worker_pool_context_t</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>prio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the thread priority of the default worker threads. This will return the current priority for one of the workers, which are all created with the same priority. If a user callback has changed one or more worker threads independently, there is no guarantee on which worker's priority is returned by this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>worker pool context whose workers' priorities are asked.</td></tr>
    <tr><td class="paramname">prio</td><td>desired priority. 1 is the highest priority allowed. 255 is the lowest priority allowed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 - success. any other value - failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a04273bd14d0e2d7edd94d7f17ff91434"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="worker__pool_8h.html#ac20a7c648028419b346fb3254aab981e">WORKERPOOL_API</a> AEEResult worker_pool_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="worker__pool_8h.html#a59a4cc2847bd9e48dd376c0ff7a2331c">worker_pool_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a worker pool. Should be called by each control thread that requires its own worker pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*context</td><td>pointer to worker_pool_context_t variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 - success. any other value - failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ad8cdece7ee5e320cb59f9fce0c89559e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="worker__pool_8h.html#ac20a7c648028419b346fb3254aab981e">WORKERPOOL_API</a> AEEResult worker_pool_init_with_stack_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="worker__pool_8h.html#a59a4cc2847bd9e48dd376c0ff7a2331c">worker_pool_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stack_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a worker pool with custom stack size of worker threads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*context</td><td>pointer to worker_pool_context_t variable. </td></tr>
    <tr><td class="paramname">*stack_size</td><td>stack size of each worker thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 - success. any other value - failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a4bf50d789d00d0dc7025438d8caf422e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="worker__pool_8h.html#ac20a7c648028419b346fb3254aab981e">WORKERPOOL_API</a> AEEResult worker_pool_set_thread_priority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="worker__pool_8h.html#a59a4cc2847bd9e48dd376c0ff7a2331c">worker_pool_context_t</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>prio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the thread priority of the worker threads. Specified priority will be applied to all threads in the default worker pool. The threads that service boosted and background job requests will also be adjusted to be relative to the new default thread priority. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>worker pool context whose workers' priorities are to be changed.</td></tr>
    <tr><td class="paramname">prio</td><td>desired priority. 1 is the highest priority allowed. 255 is the lowest priority allowed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 - success. any other value - failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ad14d34a9bcb539b0497919718088f8fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="worker__pool_8h.html#ac20a7c648028419b346fb3254aab981e">WORKERPOOL_API</a> AEEResult worker_pool_submit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="worker__pool_8h.html#a59a4cc2847bd9e48dd376c0ff7a2331c">worker_pool_context_t</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structworker__pool__job__t.html">worker_pool_job_t</a>&#160;</td>
          <td class="paramname"><em>job</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a job to the worker pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>worker pool context where job is to be submitted.</td></tr>
    <tr><td class="paramname">job</td><td>callback function pointer and data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 - success. any other value - failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ad80249e93b966c3078003bb287acd793"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="worker__pool_8h.html#ac20a7c648028419b346fb3254aab981e">WORKERPOOL_API</a> void worker_pool_synctoken_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structworker__synctoken__t.html">worker_synctoken_t</a> *&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>njobs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a synchronization token for job submitter and workers to use. Each worker callback must be given access to the token to release it, and job submitter will wait for all jobs to release the token. Internals are hidden from client. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>pointer to the synctoken structure.</td></tr>
    <tr><td class="paramname">njobs</td><td>number of jobs that will be releasing the token </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa2c041e704dfeaf36f56fdf5755f59ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="worker__pool_8h.html#ac20a7c648028419b346fb3254aab981e">WORKERPOOL_API</a> void worker_pool_synctoken_jobdone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structworker__synctoken__t.html">worker_synctoken_t</a> *&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Needs to be called by the worker in the callback before exiting. The token must be available to the callback via the data pointer given to the callback during job submission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>pointer to the synctoken structure held by the job submitter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c9cab6a5eb138c6073688a80b6404c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="worker__pool_8h.html#ac20a7c648028419b346fb3254aab981e">WORKERPOOL_API</a> void worker_pool_synctoken_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structworker__synctoken__t.html">worker_synctoken_t</a> *&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Job submitter calls this function after submitting all jobs to await their completion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>pointer to the synctoken structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_6719ab1f1f7655efc2fa43f7eb574fd1.html">libs</a></li><li class="navelem"><a class="el" href="dir_fa3b8caf0c9225f843ea34d99ca631ff.html">worker_pool</a></li><li class="navelem"><a class="el" href="dir_f504cc5c876ab725942417ca546caa35.html">inc</a></li><li class="navelem"><a class="el" href="worker__pool_8h.html">worker_pool.h</a></li>
    <li class="footer">Copyright © 2020 Qualcomm Technologies Inc. All rights reserved.  Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
